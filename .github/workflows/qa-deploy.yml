name: QA Deploy

on:
  schedule:
    - cron: '0 9 * * *' # 2AM PDT every day
  workflow_dispatch:
  push:
    branches: [main]

jobs:
  detect-and-deploy:
    runs-on: ubuntu-latest
    env:
      ECR_REGISTRY: 949882743811.dkr.ecr.us-east-1.amazonaws.com
      AWS_REGION: us-east-1

    steps:
    - name: Checkout infra repo
      uses: actions/checkout@v3

    - name: Checkout source repo
      uses: actions/checkout@v3
      with:
        repository: dingjunyu888/final-devops-project
        token: ${{ secrets.GH_PERSONAL_ACCESS_TOKEN }}
        path: source

    - name: Extract commit message from source repo
      id: commit
      run: |
        cd source
        echo "msg=$(git log -1 --pretty=%B)" >> $GITHUB_OUTPUT

    - name: Detect which service changed
      id: detect
      run: |
        msg="${{ steps.commit.outputs.msg }}"
        echo "Detected commit: $msg"

        if [[ "$msg" == user-service:* ]]; then
          echo "service=user-service" >> $GITHUB_OUTPUT
          echo "context=source/backend/user-service" >> $GITHUB_OUTPUT
        elif [[ "$msg" == product-service:* ]]; then
          echo "service=product-service" >> $GITHUB_OUTPUT
          echo "context=source/backend/product-service" >> $GITHUB_OUTPUT
        elif [[ "$msg" == order-service:* ]]; then
          echo "service=order-service" >> $GITHUB_OUTPUT
          echo "context=source/backend/order-service" >> $GITHUB_OUTPUT
        elif [[ "$msg" == frontend:* ]]; then
          echo "service=frontend" >> $GITHUB_OUTPUT
          echo "context=source/frontend" >> $GITHUB_OUTPUT
        else
          echo "‚ùå No target service detected. Skipping."
          exit 78
        fi

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      run: |
        aws ecr get-login-password --region $AWS_REGION | \
        docker login --username AWS --password-stdin $ECR_REGISTRY

    - name: Build and push image to ECR (qa-latest)
      run: |
        SERVICE=${{ steps.detect.outputs.service }}
        CONTEXT=${{ steps.detect.outputs.context }}
        IMAGE=$ECR_REGISTRY/$SERVICE:qa-latest

        echo "üì¶ Building and pushing $IMAGE from $CONTEXT"
        docker build -t $IMAGE --platform linux/amd64 $CONTEXT
        docker push $IMAGE

    # üëá Real QA Integration Begins Here

    - name: Start EC2 Instance for QA Testing
      run: |
        INSTANCE_ID=$(aws ec2 run-instances --image-id ami-05b10e08d247fb927 --instance-type t2.micro --key-name spa --security-group-ids sg-071cee3302403d191 --subnet-id subnet-0cc84b17429331c3d --query "Instances[0].InstanceId" --output text)
        echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
        echo "::set-output name=instance_id::$INSTANCE_ID"
        echo "Started EC2 instance: $INSTANCE_ID"

    - name: Wait for EC2 Instance to be Running
      run: |
        aws ec2 wait instance-running --instance-ids $INSTANCE_ID
        echo "‚úÖ EC2 is running."

    - name: Get EC2 Public IP
      id: get-ec2-ip
      run: |
        PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[*].Instances[*].PublicIpAddress" --output text)
        echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
        echo "::set-output name=public_ip::$PUBLIC_IP"

    - name: Wait for EC2 Status Checks
      run: |
        echo "Waiting for EC2 health checks..."
        sleep 30
        aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID
        echo "‚úÖ EC2 is healthy."

    - name: Set up SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" | base64 --decode > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ steps.get-ec2-ip.outputs.public_ip }} >> ~/.ssh/known_hosts

    - name: Access EC2 and Install Docker
      run: |
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ec2-user@${{ steps.get-ec2-ip.outputs.public_ip }} \
        "sudo yum update -y && \
        sudo yum install -y docker git && \
        sudo service docker start && \
        sudo usermod -aG docker ec2-user && \
        sudo curl -L 'https://github.com/docker/compose/releases/download/v2.10.2/docker-compose-$(uname -s)-$(uname -m)' -o /usr/local/bin/docker-compose && \
        sudo chmod +x /usr/local/bin/docker-compose && \
        aws configure set aws_access_key_id '${{ secrets.AWS_ACCESS_KEY_ID }}' && \
        aws configure set aws_secret_access_key '${{ secrets.AWS_SECRET_ACCESS_KEY }}' && \
        aws configure set aws_session_token '${{ secrets.AWS_SESSION_TOKEN }}' && \
        aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $ECR_REGISTRY"

    - name: Pull Docker Image from ECR
      run: |
        SERVICE=${{ steps.detect.outputs.service }}
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ec2-user@${{ steps.get-ec2-ip.outputs.public_ip }} \
        "docker pull $ECR_REGISTRY/$SERVICE:qa-latest"

    - name: Run Container and Perform Smoke Test
      run: |
        SERVICE=${{ steps.detect.outputs.service }}
        PORT=3000
        if [[ "$SERVICE" == "user-service" ]]; then PORT=3001; fi
        if [[ "$SERVICE" == "product-service" ]]; then PORT=3002; fi
        if [[ "$SERVICE" == "order-service" ]]; then PORT=3003; fi
        if [[ "$SERVICE" == "frontend" ]]; then PORT=5173; fi

        ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ec2-user@${{ steps.get-ec2-ip.outputs.public_ip }} \
        "docker run -d --name $SERVICE -p $PORT:$PORT $ECR_REGISTRY/$SERVICE:qa-latest && \
        sleep 15 && \
        curl -I http://localhost:$PORT || echo '‚ö†Ô∏è Service may not be responding'"

    - name: Clean up EC2 instance
      if: always()
      run: |
        aws ec2 terminate-instances --instance-ids $INSTANCE_ID
        echo "üßπ Terminated QA EC2 instance."
